const e=JSON.parse('{"key":"v-071be141","path":"/git/use-command-line-tool-to-manage-gitlab-merge-request.html","title":"操作 Gitlab MR 的命令行工具","lang":"zh-CN","frontmatter":{"date":"2023-03-23T00:00:00.000Z","tag":["Git","GitLab","Python"],"description":"操作 Gitlab MR 的命令行工具 背景 为什么开发这个工具？主要解决以下问题： 提测、上 UAT 时，避免漏合代码。 代码冲突时，团队成员不用再问“解决这个冲突要怎么切分支？” 一个 feature 分支要向多个保护分支提交合并请求时，减少烦琐而易错的选取分支的界面操作。 可能会有人问：为什么会漏合代码？当你在某一个迭代需要来回在不同的 feature 分支切换、一个 feature 横跨多个项目，同时你偶尔还要兼顾 bug 修复的时候，你极容易丢失上下文。 并且，不同的 feature 研发进度不一致，可能出现的一种情况是：feature A 只是合并到 test 分支，但　feature B 却已经合并到了 uat。 对此，有人问你代码到底合并了没，你怎么确认？一个个项目去相应的主干分支里查看提交历史吗？就是因为不想再这样做了，这才有了这个工具。","head":[["meta",{"property":"og:url","content":"https://levy.vip/git/use-command-line-tool-to-manage-gitlab-merge-request.html"}],["meta",{"property":"og:site_name","content":"levy"}],["meta",{"property":"og:title","content":"操作 Gitlab MR 的命令行工具"}],["meta",{"property":"og:description","content":"操作 Gitlab MR 的命令行工具 背景 为什么开发这个工具？主要解决以下问题： 提测、上 UAT 时，避免漏合代码。 代码冲突时，团队成员不用再问“解决这个冲突要怎么切分支？” 一个 feature 分支要向多个保护分支提交合并请求时，减少烦琐而易错的选取分支的界面操作。 可能会有人问：为什么会漏合代码？当你在某一个迭代需要来回在不同的 feature 分支切换、一个 feature 横跨多个项目，同时你偶尔还要兼顾 bug 修复的时候，你极容易丢失上下文。 并且，不同的 feature 研发进度不一致，可能出现的一种情况是：feature A 只是合并到 test 分支，但　feature B 却已经合并到了 uat。 对此，有人问你代码到底合并了没，你怎么确认？一个个项目去相应的主干分支里查看提交历史吗？就是因为不想再这样做了，这才有了这个工具。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-10T03:42:01.000Z"}],["meta",{"property":"article:author","content":"levy"}],["meta",{"property":"article:tag","content":"Git"}],["meta",{"property":"article:tag","content":"GitLab"}],["meta",{"property":"article:tag","content":"Python"}],["meta",{"property":"article:published_time","content":"2023-03-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-10T03:42:01.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"操作 Gitlab MR 的命令行工具\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-23T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-10T03:42:01.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"levy\\"}]}"]]},"headers":[{"level":2,"title":"背景","slug":"背景","link":"#背景","children":[]},{"level":2,"title":"安装","slug":"安装","link":"#安装","children":[{"level":3,"title":"解压zip","slug":"解压zip","link":"#解压zip","children":[]},{"level":3,"title":"安装git bash","slug":"安装git-bash","link":"#安装git-bash","children":[]}]},{"level":2,"title":"配置","slug":"配置","link":"#配置","children":[{"level":3,"title":"gitlab_token","slug":"gitlab-token","link":"#gitlab-token","children":[]},{"level":3,"title":"codebases","slug":"codebases","link":"#codebases","children":[]},{"level":3,"title":"环境变量","slug":"环境变量","link":"#环境变量","children":[]},{"level":3,"title":"IDEA","slug":"idea","link":"#idea","children":[]}]},{"level":2,"title":"使用","slug":"使用","link":"#使用","children":[{"level":3,"title":"创建MR","slug":"创建mr","link":"#创建mr","children":[]},{"level":3,"title":"查看MR","slug":"查看mr","link":"#查看mr","children":[]},{"level":3,"title":"合并MR","slug":"合并mr","link":"#合并mr","children":[]},{"level":3,"title":"冲突处理","slug":"冲突处理","link":"#冲突处理","children":[]}]}],"git":{"createdTime":1696909321000,"updatedTime":1696909321000,"contributors":[{"name":"levy","email":"chenriwei@deepexi.com","commits":1}]},"readingTime":{"minutes":4.42,"words":1325},"filePathRelative":"git/use-command-line-tool-to-manage-gitlab-merge-request.md","localizedDate":"2023年3月23日","excerpt":"<h1> 操作 Gitlab MR 的命令行工具</h1>\\n<h2> 背景</h2>\\n<p>为什么开发这个工具？主要解决以下问题：</p>\\n<ol>\\n<li>提测、上 UAT 时，避免漏合代码。</li>\\n<li>代码冲突时，团队成员不用再问“解决这个冲突要怎么切分支？”</li>\\n<li>一个 feature 分支要向多个保护分支提交合并请求时，减少烦琐而易错的选取分支的界面操作。</li>\\n</ol>\\n<p>可能会有人问：为什么会漏合代码？当你在某一个迭代需要来回在不同的 feature 分支切换、一个 feature 横跨多个项目，同时你偶尔还要兼顾 bug 修复的时候，你极容易丢失上下文。<br>\\n并且，不同的 feature 研发进度不一致，可能出现的一种情况是：feature A 只是合并到 test 分支，但　feature B 却已经合并到了 uat。<br>\\n对此，有人问你代码到底合并了没，你怎么确认？一个个项目去相应的主干分支里查看提交历史吗？就是因为不想再这样做了，这才有了这个工具。</p>","autoDesc":true}');export{e as data};
