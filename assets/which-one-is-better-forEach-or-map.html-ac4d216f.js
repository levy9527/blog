import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,f as p}from"./app-5fad1304.js";const t={},e=p(`<h1 id="foreach-还是-map" tabindex="-1"><a class="header-anchor" href="#foreach-还是-map" aria-hidden="true">#</a> forEach 还是 map？</h1><h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h2><p>遍历一个集合，在里面执行某种操作后，再依次返回每一个元素，常见的实现方式有：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Type</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>src <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">Type</span> target <span class="token operator">=</span> <span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">copyProperties</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//省略代码</span>
    result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Type</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>src <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">Type</span> target <span class="token operator">=</span> <span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">copyProperties</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//省略代码</span>
   <span class="token keyword">return</span> target<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两种方式看起来没多大差别啊，到底用哪种呢？</p><h2 id="结论" tabindex="-1"><a class="header-anchor" href="#结论" aria-hidden="true">#</a> 结论</h2><p>先说结论：根据《Effective Java》(第三版），forEach 只用于消费数据的场景，并不应该用于计算、累加，故上述代码应该使用 map。</p><p>原文如下：<br><img src="https://raw.gitmirror.com/levy9527/image-holder/main/md-image-kit/1654151903594-61668916-08c9-4349-9429-024742b14fac.png" alt=""></p><blockquote><p>红字处翻译：forEach 仅适用于输出 stream 里的计算结果，并不适合执行计算。</p></blockquote><h2 id="解析" tabindex="-1"><a class="header-anchor" href="#解析" aria-hidden="true">#</a> 解析</h2><p>为更好地理解上述结论，需要先理解以下内涵：<br><img src="https://raw.gitmirror.com/levy9527/image-holder/main/md-image-kit/1654153524133-3fcb016b-8dae-4482-807b-952b5dd0ca6e.png" alt=""><br> Stream 的引入，不仅带来新的语法，也带来了函数式编程的思维。</p><p>这里最重要的一点就是：编写纯函数（pure function），不造成副作用（side-effect）。</p><p>纯函数可以用数学中的函数映射来理解：y = f(x)</p><ul><li>给定 x，能唯一确定 y</li><li>无论函数调用几次、在何处调用，上述结果都不会变化</li></ul><p>无副作用意思是：调用函数后，不会对函数作用域以外的变量造成影响。而纯函数，一定是无副作用的。</p><p>前文使用 forEach 的代码，其实是造成了副作用的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Type</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>src <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">Type</span> target <span class="token operator">=</span> <span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">copyProperties</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//side effect</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很简单的一个识别方法：再调用一次 forEach，result 的结果还是期望的结果吗？显然不是。</p><p>但如果 map 方法呢？再调用一次，结果不变！</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Type</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>src <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">Type</span> target <span class="token operator">=</span> <span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">copyProperties</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> target<span class="token punctuation">;</span> <span class="token comment">// side effect free</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类似的，修改函数入参，也不是纯函数：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> ids <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">collectIds</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> ids<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在这里填充 ids！</span>

<span class="token keyword">int</span> size <span class="token operator">=</span> ids<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的 <code>collectIds</code>函数是令人讨厌的——写代码的人懒得写函数返回时，直接修改函数入参，给后面维护的人留下隐患。</p><p>当然，如果一定要用纯函数来看待问题，未免过于理想化，因为有时要执行这样的代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>v <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    myService<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然上述代码并没影响到函数作用域以外的代码变量，但 myService 会把数据持久化，站在整个应用的角度讲，仍然造成了副作用。</p><p>但上述代码可以接受的。因此，建议记住 forEach 只用于消费数据，不用于计算及返回，就不容易混淆。</p><h2 id="实战" tabindex="-1"><a class="header-anchor" href="#实战" aria-hidden="true">#</a> 实战</h2><p>当然，上述的讨论还是比较偏理论的，我们来看一下实际项目中，滥用 forEach 可能导致可读性较差的问题。</p><p>代码一开始，是简单清晰的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 一个只有20行的函数</span>
<span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> nodes<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Type1</span> var1<span class="token punctuation">;</span>
    <span class="token class-name">Type2</span> var2<span class="token punctuation">;</span>
    
    nodes<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>node <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 修改 var1</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
      
    edges<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>edge <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 修改 var2</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然而，业务会变化，逻辑会复杂，代码也要修改。而上述在 forEach 中修改变量的行为，罪恶的根源在于，它在向后来修改代码的人发出邀请：新增的逻辑，写在这个 forEach 里面就好了！</p><p>当仅在 forEach 添加代码就能完成任务的时候，很难有人能抵抗这种诱惑，于是就会变成：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 一个超过50行的函数</span>
<span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> nodes<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Type1</span> var1<span class="token punctuation">;</span>
    <span class="token class-name">Type2</span> var2<span class="token punctuation">;</span>
    <span class="token class-name">Type3</span> var3<span class="token punctuation">;</span>
    <span class="token class-name">Type4</span> var4<span class="token punctuation">;</span>
    <span class="token class-name">Type5</span> var5<span class="token punctuation">;</span>
    
    nodes<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>node <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 里面有多个 if-else</span>
        <span class="token comment">// 修改了 var1, var2</span>
        <span class="token comment">// 有可能修改 var5</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
      
    edges<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>edge <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 里面有多个 if-else</span>
        <span class="token comment">// 修改了 var3, var4</span>
        <span class="token comment">// 有可能修改 var5</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>写代码一时爽，维护火葬场。上面的代码，将是维护的噩梦！</p><p>并且，如果维护者只想知道函数的整体逻辑，由于变量穿插、隐藏在 forEach 内部，维护者不得不在各种 if-else 里面追踪变量，很容易就陷入不必要的细节中。</p><p>如果换个方式来写呢？</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> nodes<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>   
    <span class="token comment">// 为代码简洁，省略了 collect(Collectors.toList())</span>
    <span class="token class-name">Type1</span> var1 <span class="token operator">=</span> nodes<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>v <span class="token operator">-&gt;</span> <span class="token function">getVar1</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Type2</span> var2 <span class="token operator">=</span> nodes<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>v <span class="token operator">-&gt;</span> <span class="token function">getVar2</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Type3</span> var3 <span class="token operator">=</span> edges<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>v <span class="token operator">-&gt;</span> <span class="token function">getVar3</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Type4</span> var4 <span class="token operator">=</span> edges<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>v <span class="token operator">-&gt;</span> <span class="token function">getVar4</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Type5</span> var5 <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>nodes<span class="token punctuation">,</span> edges<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>v <span class="token operator">-&gt;</span> <span class="token function">filterVar5</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果有大大的不同！</p><p>现在想追查哪个变量，简单轻松好多啦！</p>`,41),c=[e];function o(l,i){return s(),a("div",null,c)}const k=n(t,[["render",o],["__file","which-one-is-better-forEach-or-map.html.vue"]]);export{k as default};
