const e=JSON.parse('{"key":"v-75616b85","path":"/software-testing/use-postman-for-api-testing.html","title":"使用 Postman 进行 API 测试","lang":"zh-CN","frontmatter":{"date":"2023-09-13T00:00:00.000Z","tag":["Node.js","Daily"],"description":"使用 Postman 进行 API 测试 前言 虽然之前分享过 RestAssured 进行接口测试的教程，但实践起来，会有阻碍：研发同学还是对 Postman 更熟悉，更倾向于使用 Postman 调试接口，而不是写 Java 代码对 Controller 层进行测试。 而笔者在针对旧的 Java 项目添加接口测试时，又遇到了另一个问题：那就是由于模块依赖，进行接口测试时，还在把旧的测试代码一并带上。虽然说有办法解决，但究竟是麻烦不断。 还有就是，Java 的类型检查，在写接口测试时十分束缚手脚。如下述代码：","head":[["meta",{"property":"og:url","content":"https://levy.vip/software-testing/use-postman-for-api-testing.html"}],["meta",{"property":"og:site_name","content":"levy"}],["meta",{"property":"og:title","content":"使用 Postman 进行 API 测试"}],["meta",{"property":"og:description","content":"使用 Postman 进行 API 测试 前言 虽然之前分享过 RestAssured 进行接口测试的教程，但实践起来，会有阻碍：研发同学还是对 Postman 更熟悉，更倾向于使用 Postman 调试接口，而不是写 Java 代码对 Controller 层进行测试。 而笔者在针对旧的 Java 项目添加接口测试时，又遇到了另一个问题：那就是由于模块依赖，进行接口测试时，还在把旧的测试代码一并带上。虽然说有办法解决，但究竟是麻烦不断。 还有就是，Java 的类型检查，在写接口测试时十分束缚手脚。如下述代码："}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-16T18:48:51.000Z"}],["meta",{"property":"article:author","content":"levy"}],["meta",{"property":"article:tag","content":"Node.js"}],["meta",{"property":"article:tag","content":"Daily"}],["meta",{"property":"article:published_time","content":"2023-09-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-16T18:48:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"使用 Postman 进行 API 测试\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-09-13T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-16T18:48:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"levy\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"本地调试","slug":"本地调试","link":"#本地调试","children":[{"level":3,"title":"接口集合","slug":"接口集合","link":"#接口集合","children":[]},{"level":3,"title":"从 cURL 导入","slug":"从-curl-导入","link":"#从-curl-导入","children":[]},{"level":3,"title":"环境变量","slug":"环境变量","link":"#环境变量","children":[]},{"level":3,"title":"请求设置","slug":"请求设置","link":"#请求设置","children":[]}]},{"level":2,"title":"接口测试","slug":"接口测试","link":"#接口测试","children":[{"level":3,"title":"编写用例","slug":"编写用例","link":"#编写用例","children":[]},{"level":3,"title":"上传文件","slug":"上传文件","link":"#上传文件","children":[]},{"level":3,"title":"运行集合","slug":"运行集合","link":"#运行集合","children":[]}]},{"level":2,"title":"持续集成","slug":"持续集成","link":"#持续集成","children":[{"level":3,"title":"导出接口","slug":"导出接口","link":"#导出接口","children":[]},{"level":3,"title":"导出环境变量","slug":"导出环境变量","link":"#导出环境变量","children":[]},{"level":3,"title":"复制要上传的文件","slug":"复制要上传的文件","link":"#复制要上传的文件","children":[]},{"level":3,"title":"提交到Git","slug":"提交到git","link":"#提交到git","children":[]},{"level":3,"title":"建立CI任务","slug":"建立ci任务","link":"#建立ci任务","children":[]}]}],"git":{"createdTime":1702752531000,"updatedTime":1702752531000,"contributors":[{"name":"levy","email":"897895407@qq.com","commits":1}]},"readingTime":{"minutes":5.51,"words":1653},"filePathRelative":"software-testing/use-postman-for-api-testing.md","localizedDate":"2023年9月13日","excerpt":"<h1> 使用 Postman 进行 API 测试</h1>\\n<h2> 前言</h2>\\n<p>虽然之前分享过 RestAssured 进行接口测试的教程，但实践起来，会有阻碍：研发同学还是对 Postman 更熟悉，更倾向于使用 Postman 调试接口，而不是写 Java 代码对 Controller 层进行测试。</p>\\n<p>而笔者在针对旧的 Java 项目添加接口测试时，又遇到了另一个问题：那就是由于模块依赖，进行接口测试时，还在把旧的测试代码一并带上。虽然说有办法解决，但究竟是麻烦不断。</p>\\n<p>还有就是，Java 的类型检查，在写接口测试时十分束缚手脚。如下述代码：</p>\\n","autoDesc":true}');export{e as data};
