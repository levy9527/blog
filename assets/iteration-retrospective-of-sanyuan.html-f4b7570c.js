import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{o as t,c as i,e as o,a as e,b as a,f as n}from"./app-31f65160.js";const d={},s=e("h1",{id:"迭代复盘之三员管理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#迭代复盘之三员管理","aria-hidden":"true"},"#"),a(" 迭代复盘之三员管理")],-1),c=e("h2",{id:"前言",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#前言","aria-hidden":"true"},"#"),a(" 前言")],-1),l=e("p",null,"本次迭代做的工作主要是回收项目能力，具体做法是把 fork 出去的代码合并回来。",-1),h=e("p",null,"这次迭代因为各种原因，延期了快一个星期（周六还加了班）。",-1),p=e("p",null,"那么，我从工作流、方法论的角度，反思了自己可以改进的点，期望在这种迁移旧代码的实践中，抽取出能复用的经验。",-1),_=n('<h2 id="动手前-至少梳理出接口清单" tabindex="-1"><a class="header-anchor" href="#动手前-至少梳理出接口清单" aria-hidden="true">#</a> 动手前，至少梳理出接口清单</h2><p>太轻信旧代码了，抱着代码迁移过来，跑起来就能用的态度，没能及时发现功能遗漏点，到了提测才发现有功能未实现，这是可以避免的。</p><p>更优的工作流应该是：</p><ol><li>先进行业务梳理</li><li>整理出接口清单</li><li>再进行代码迁移</li><li>根据接口清单，逐个验证迁移的代码是否符合需求</li></ol><h2 id="迁移时-采取结队编程" tabindex="-1"><a class="header-anchor" href="#迁移时-采取结队编程" aria-hidden="true">#</a> 迁移时，采取结队编程</h2><p>看到有 500 个文件要迁移，觉得用分治的思路去实现会更高效，但这种思维有一个误区：做得快不等于有效率，因为效率需要的是有用功，而不是无用功。</p><p>实践表明，初期对业务的理解、代码的熟悉程度还不够深入，迁移代码遇到分歧点时，个人在独自处理时容易产生错误——而这种错误并不自知，这才是最蛋疼的地方。</p><p>所以，我才建议，采取结队编程实践，两个人一起来迁移代码，这样子遇到分歧时可以讨论，而不是贸然行动。表面上看，这样的进程慢了，实际上却能提高对代码、业务的理解，提高了迁移的正确率，真正地提高效率。</p><h2 id="迁移后-需要对自己负责的功能设计测试用例" tabindex="-1"><a class="header-anchor" href="#迁移后-需要对自己负责的功能设计测试用例" aria-hidden="true">#</a> 迁移后，需要对自己负责的功能设计测试用例</h2><p>这里的本质，是不能完全依赖别人。虽然测试人员会编写测试用例，也会进行用例评审，但这里会有两个问题：</p><ol><li>前期评审时，自己的心思可能在理解业务、功能设计与改造以及代码迁移，没有多少心思能去 debug 用例的精细程度</li><li>测试也是人，也会有遗漏，并且没有接触源码，有些特殊的、极端的边界场景，自己作为研发人员，更容易发现</li></ol><p>可以看成，我们自己设计的用例是对测试人员给出的测试用例的补充。</p><p>当然，由于时间的关系，做完善的测试一般都不太可能了。<br> 对于 legacy code，想补充 service 层的单元测试成本是很高的。写 controller 层的测试，可能也没有太多时间。<br> 但至少应该用 postman 进行调试，或者在用户界面上点几下，不能完全等着前端或测试人员反馈，认为没有反馈就是没有 bug。</p>',13);function f(u,m){return t(),i("div",null,[s,c,l,h,p,o(" more "),_])}const v=r(d,[["render",f],["__file","iteration-retrospective-of-sanyuan.html.vue"]]);export{v as default};
