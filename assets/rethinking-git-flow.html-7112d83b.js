const e=JSON.parse('{"key":"v-0fbf5fdc","path":"/git/rethinking-git-flow.html","title":"再论Git Flow","lang":"zh-CN","frontmatter":{"date":"2022-04-21T00:00:00.000Z","tag":"Git","description":"再论Git Flow 背景 团队目前使用的 Git 协作模式是： 对每个功能建立相应的 feat 分支 上研发、测试、UAT环境时，分别把相应的 feat 分支合并进入长驻 dev/test/uat 如有冲突，则在本地更新长驻分支 dev/test/uat，merge feat into current branch，之后 checkout 一个新分支，作为 conflict resolved 分支，推送并合并至远程长驻分支 这个模式简单好懂，且业界流行，最直观的好处是，可以满足以下需求：","head":[["meta",{"property":"og:url","content":"https://levy.vip/git/rethinking-git-flow.html"}],["meta",{"property":"og:site_name","content":"levy"}],["meta",{"property":"og:title","content":"再论Git Flow"}],["meta",{"property":"og:description","content":"再论Git Flow 背景 团队目前使用的 Git 协作模式是： 对每个功能建立相应的 feat 分支 上研发、测试、UAT环境时，分别把相应的 feat 分支合并进入长驻 dev/test/uat 如有冲突，则在本地更新长驻分支 dev/test/uat，merge feat into current branch，之后 checkout 一个新分支，作为 conflict resolved 分支，推送并合并至远程长驻分支 这个模式简单好懂，且业界流行，最直观的好处是，可以满足以下需求："}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-29T07:08:26.000Z"}],["meta",{"property":"article:author","content":"levy"}],["meta",{"property":"article:tag","content":"Git"}],["meta",{"property":"article:published_time","content":"2022-04-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-01-29T07:08:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"再论Git Flow\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-21T00:00:00.000Z\\",\\"dateModified\\":\\"2024-01-29T07:08:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"levy\\"}]}"]]},"headers":[{"level":2,"title":"背景","slug":"背景","link":"#背景","children":[]},{"level":2,"title":"动机","slug":"动机","link":"#动机","children":[]},{"level":2,"title":"分析","slug":"分析","link":"#分析","children":[{"level":3,"title":"剔除代码","slug":"剔除代码","link":"#剔除代码","children":[]},{"level":3,"title":"再次提交","slug":"再次提交","link":"#再次提交","children":[]},{"level":3,"title":"比较优劣","slug":"比较优劣","link":"#比较优劣","children":[]}]},{"level":2,"title":"实例","slug":"实例","link":"#实例","children":[{"level":3,"title":"分支模型","slug":"分支模型","link":"#分支模型","children":[]},{"level":3,"title":"功能提交","slug":"功能提交","link":"#功能提交","children":[]},{"level":3,"title":"功能回撤","slug":"功能回撤","link":"#功能回撤","children":[]}]},{"level":2,"title":"结论","slug":"结论","link":"#结论","children":[]}],"git":{"createdTime":1706512106000,"updatedTime":1706512106000,"contributors":[{"name":"levy","email":"chenriwei@deepexi.com","commits":1}]},"readingTime":{"minutes":5.53,"words":1660},"filePathRelative":"git/rethinking-git-flow.md","localizedDate":"2022年4月21日","excerpt":"<h1> 再论Git Flow</h1>\\n<h2> 背景</h2>\\n<p>团队目前使用的 Git 协作模式是：</p>\\n<ol>\\n<li>对每个功能建立相应的 feat 分支</li>\\n<li>上研发、测试、UAT环境时，分别把相应的 feat 分支合并进入长驻 dev/test/uat</li>\\n<li>如有冲突，则在本地更新长驻分支 dev/test/uat，merge feat into current branch，之后 checkout 一个新分支，作为 conflict resolved 分支，推送并合并至远程长驻分支</li>\\n</ol>\\n<p>这个模式简单好懂，且业界流行，最直观的好处是，可以满足以下需求：</p>","autoDesc":true}');export{e as data};
